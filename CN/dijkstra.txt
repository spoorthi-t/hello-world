import java.util.Scanner;
public class Dijkstrarouting {
// Use a large value to represent "infinite" distance
static final int INF = 9999;
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.print("Enter number of nodes: ");
int n = sc.nextInt();
int[][] graph = new int[n][n];
System.out.println("Enter adjacency matrix (0 means no direct link):");
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
graph[i][j] = sc.nextInt();
}
}
// Run Dijkstra for each node as source
for (int src = 0; src < n; src++) {
dijkstra(graph, n, src);
}
sc.close();
}
// Dijkstraâ€™s algorithm for one source node
static void dijkstra(int[][] graph, int n, int src) {
int[] dist = new int[n]; // shortest distances
boolean[] visited = new boolean[n]; // visited nodes
int[] parent = new int[n]; // parent array to find next hop
// initialize arrays WITHOUT Arrays.fill()
for (int i = 0; i < n; i++) {
dist[i] = INF;
visited[i] = false;
parent[i] = -1;
}
dist[src] = 0; // distance to itself is 0
for (int count = 0; count < n - 1; count++) {
int u = minDistance(dist, visited, n);
if (u == -1) break; // no reachable unvisited vertex left
visited[u] = true;
// update distance values of the adjacent nodes
for (int v = 0; v < n; v++) {
if (!visited[v] && graph[u][v] != 0 && dist[u] != INF
&& dist[u] + graph[u][v] < dist[v]) {
dist[v] = dist[u] + graph[u][v];
parent[v] = u;
}
}
}
// Print routing table for this node
printRoutingTable(src, n, dist, parent);
}
// Find the node with the minimum distance that is not yet visited
static int minDistance(int[] dist, boolean[] visited, int n) {
int min = INF;
int minIndex = -1;
for (int i = 0; i < n; i++) {
if (!visited[i] && dist[i] < min) {
min = dist[i];
minIndex = i;
}
}
return minIndex;
}
// Print routing table for one source node
static void printRoutingTable(int src, int n, int[] dist, int[] parent) {
System.out.println("\nRouting Table for Node " + src + ":");
System.out.println("Destination\tNextHop\tDistance");
for (int i = 0; i < n; i++) {
if (i == src) continue;
int nextHop = findNextHop(src, i, parent);
String nh = (nextHop == -1) ? "-" : Integer.toString(nextHop);
String d = (dist[i] == INF) ? "INF" : Integer.toString(dist[i]);
System.out.println(i + "\t\t" + nh + "\t\t" + d);
}
}
// Find the next hop from src to destination using parent array
static int findNextHop(int src, int dest, int[] parent) {
if (dest == src) return src;
if (parent[dest] == -1) return -1; // unreachable
int hop = dest;
while (parent[hop] != -1 && parent[hop] != src) {
hop = parent[hop];
}
if (parent[hop] == -1 && parent[dest] != src) return -1;
return hop;
}
}
OUTPUT:
Enter number of nodes: 5
Enter adjacency matrix (0 means no
direct link):
0 10 3 0 0
10 0 1 2 0
3 1 0 8 2
0 2 8 0 7
0 0 2 7 0
Routing Table for Node 0:
Destination NextHop Distance
1 2 4
2 2 3
3 2 6
4 2 5
Routing Table for Node 1:
Destination NextHop Distance
0 2 4
2 2 1
3 3 2
4 2 3
Routing Table for Node 2:
Destination NextHop Distance
0 0 3
1 1 1
3 1 3
4 4 2
Routing Table for Node 3:
Destination NextHop Distance
0 1 6
1 1 2
2 1 3
4 1 5
Routing Table for Node 4:
Destination NextHop Distance
0 2 5
1 2 3
2 2 2
3 2 5